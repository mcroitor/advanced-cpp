# Алгоритмы

### Определение: _Алгоритм это конечная последовательность действий, приводящая к желаемому результату._

###  Определение: _Предикатом называется функция, возвращающая логическое значение._

Все алгоритмы стандартной библиотеки шаблонов отделены от деталей реализации структур данных и используют в качестве параметров типы итераторов. Поэтому они могут работать с определяемыми пользователем структурами данных, когда эти структуры данных имеют типы итераторов, удовлетворяющие предположениям в алгоритмах.   
  
Для некоторых алгоритмов предусмотрены как оперативные версии \(то есть результат сохраняется в указаном итераторами сегменте\), так и копирующие версии. Решение, включать ли копирующую версию в библиотеку, было основано на рассмотрении эфективности алгоритма. Когда стоимость выполнения операции доминирует над стоимостью копии, копирующая версия не включена. Например, sort\_copy не включена, так как стоимость сортировки намного значительнее, и пользователи могли бы также делать copy перед sort. Копирующая версия алгоритма _algorithm _называется _algorithm\_copy _\(добавляется суффикс \_copy\). В копирующих алгоритмах не указывается конец второго интервала, так как он может быть вычислен исходя их длины первого интервала.

Кроме того, для некоторых алгоритмов существуют предикатные версии. Алгоритмы, которые берут предикаты, оканчиваются суффиксом \_if \(который следует за суффиксом \_copy в случае копирующего алгоритма\).   
  
Класс Predicate используется всякий раз, когда алгоритм ожидает функциональный объект, при применении которого к результату разыменования соответствующего итератора возвращается значение, обратимое в bool. Другими словами, если алгоритм берёт _Predicate pred_ как свой параметр и first как свой параметр итератора, он должен работать правильно в конструкции _if \(pred\(\*first\)\) {...}_. Предполагается, что функциональный объект pred не применяет какую-либо непостоянную функцию для разыменованного итератора.   
  
Класс _BinaryPredicate _используется всякий раз, когда алгоритм ожидает функциональный объект, который при его применении к результату разыменования двух соответствующих итераторов или к разыменованию итератора и типа T, когда T - часть сигнатуры, возвращает значение, обратимое в bool. Другими словами, если алгоритм берёт _BinaryPredicate binary\_pred_ как свой параметр и first1 и first2 как свои параметры итераторов, он должен работать правильно в конструкции _if \(binary\_pred\(\*first, \*first2\)\) {...}_. _BinaryPredicate _всегда берёт тип первого итератора как свой первый параметр, то есть в тех случаях, когда T value - часть сигнатуры, он должен работать правильно в контексте_ if \(binary\_pred \(\*first, value\)\) {...}_. Ожидается, что binary\_pred не будет применять какую-либо непостоянную функцию для разыменованных итераторов.

Существуют алгоритмы, меняющие последовательность и не меняющие последовательность. Ниже описаны наиболее часто встречающиеся алгоритмы.

## Алгоритмы, не меняющие последовательность

| Название | синтаксис | Пояснение |
| --- | --- | --- | --- | --- | --- |
| **for\_each** | template &lt;class InputIterator, class Function&gt; Function for\_each\(InputIterator first, InputIterator last, Function f\); | for\_each применяет f к результату разыменования каждого итератора в диапазоне \[first, last\) и возвращает f. Принято, что f не применяет какую-то непостоянную функцию к разыменованному итератору. f применяется точно last-first раз. Если f возвращает результат, результат игнорируется. |
| **find** | template &lt;class InputIterator, class T&gt; InputIterator find\(InputIterator first, InputIterator last, const T& value\);  template &lt;class InputIterator, class Predicate&gt; InputIterator find\_if\(InputIterator first, InputIterator last, Predicate pred\); | find возвращает первый итератор i в диапазоне \[first, last\), для которого соблюдаются следующие соответствующие условия: \*i == value, pred \(\*i\) == true. Если такой итератор не найден, возвращается last. Соответствующий предикат применяется точно find\(first, last, value\) - first раз. |
| **count** | template &lt;class InputIterator, class T&gt; typename iterator\_traits&lt;InputIterator&gt;::difference\_type count \(InputIterator first, InputIterator last, const T& val\);  template &lt;class InputIterator, class Predicate&gt; typename iterator\_traits&lt;InputIterator&gt;::difference\_type count\_if \(InputIterator first, InputIterator last, UnaryPredicate pred\); | count подсчитывает число итераторов i в диапазоне \[first, last\), для которых соблюдаются следующие соответствующие условия: \*i == value, pred \(\*i\) == true. Соответствующий предикат применяется точно last-first раз. |
| **equal** | template &lt;class InputIterator1, class InputIterator2&gt; bool equal\(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2\);  template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt; bool equal\(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,  BinaryPredicate binary\_pred\); | equal возвращает true, если для каждого итератора i в диапазоне \[first1, last1\) выполнены следующие соответствующие условия: \*i == \*\(first2 + \(i - first1\)\), binary\_pred\(\*i, \*\(first2 + \(i - first1\)\)\) == true. Иначе equal возвращает false. Соответствующий предикат применяется, самое большее, last1 - first1 раз. |
| **search** | template &lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator1 search\(ForwardIterator1 first1, ForwardIterator1 last1,  ForwardIterator2 first2, ForwardIterator2 last2\);  template &lt;class ForwardIterator1, class ForwardIterator2,  class BinaryPredicate&gt; ForwardIterator1 search\(ForwardIterator1 first1, ForwardIterator1 last1,  ForwardIterator2 first2, ForwardIterator2 last2,  BinaryPredicate binary\_pred\); | search находит подпоследовательность равных значений в последовательности. search возвращает первый итератор i в диапазоне \[first1, last1 - \(last2 - first2\)\) такой, что для любого неотрицательного целого числа n, меньшего чем last2 - first2, выполнены следующие соответствующие условия: \*\(i + n\) == \*\(first2 + n\), binary\_pred\(\*\(i + n\), \*\(first2 + n\)\) == true. Если такой итератор не найден, возвращается last1. Соответствующий предикат применяется, самое большее, \(last1  - first1\) \* \(last2 - first2\) раз. Квадратичное поведение, однако, является крайне маловероятным. |

## Алгоритмы, меняющие последовательность

В связи с тем, что эти алгоритмы меняют контейнеры, итераторы, с которыми алгоритмы работают, могут оказаться недействительными. Поэтому не рекомендуется использовать один и тот же итератор при работе с алгоритмами.

| Название | синтаксис | Пояснение |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| copy | template &lt;class InputIterator, class OutputIterator&gt; OutputIterator copy\(InputIterator first, InputIterator last,     OutputIterator result\);template &lt;class BidirectionalIterator1, class BidirectionalIterator2&gt; BidirectionalIterator2 copy\_backward\(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result\); | Алгоритм copy копирует элементы из полуинтервала \[first, last\) в полуинтервал \[result, result + \(last-first\)\). Полуинтервалы должны существовать и не пересекаться.Алгоритм copy\_backward копирует элементы полуинтервала в обратном порядке. |
| swap | template &lt; class T &gt; void swap \(T& a , T& b \);template &lt; class ForwardIterator1 , class ForwardIterator2 &gt; ForwardIterator2 swap\_ranges \( ForwardIterator1 first1 , ForwardIterator1 last1 , ForwardIterator2 first2 \);template &lt; class ForwardIterator1 , class ForwardIterator2 &gt; void iter\_swap \( ForwardIterator1 a , ForwardIterator2 b \); | Этот алгоритм предназначен для обмена значений между двумя переменными \(объектами\). Также существует реализация для обмена значений итераторов и полуинтервалов. |
| replace | template &lt; class ForwardIterator , class T&gt; void replace \( ForwardIterator first , ForwardIterator last , const T& old\_value , const T& new\_value \);template &lt; class ForwardIterator , class Predicate , class T&gt; void replace\_if \( ForwardIterator first , ForwardIterator last , Predicate pred , const T& new\_value \);template &lt; class InputIterator , class OutputIterator , class T&gt; OutputIterator replace\_copy \( InputIterator first , InputIterator last , OutputIterator result , const T& old\_value , const T& new\_value \);template &lt; class InputIterator , class OutputIterator , class Predicate , class T&gt; OutputIterator replace\_copy\_if \( InputIterator first , InputIterator last ,OutputIterator result , Predicate pred , const T& new\_value \); | Алгоритм replace заменяет все элементы из указываемого полуинтервала, равные old\_value, на new\_value. Предикатная форма алгоритма заменяет все элементы, которые удовлетворяют условию предиката. |
| transform | template &lt; class InputIterator , class OutputIterator , class UnaryOperation &gt; OutputIterator transform \( InputIterator first , InputIterator last , OutputIterator result , UnaryOperation op \);template &lt; class InputIterator1 , class InputIterator2 , class OutputIterator , class BinaryOperation &gt; OutputIterator transform \( InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result , BinaryOperation binary\_op\); | Данный алгоритм применяет функтор к элементам полуинтервала \[first, last\) и результат unary\_op\(\*it\)  записывает в полуинтервал \[result, result + \(last-first\)\).Вторая форма олгоритма transform выбирает значения из двух полуинтервалов, и результат и результат binary\_op\(\*it1, \*it2\)  аписывает в полуинтервал \[result, result + \(last-first\)\). |
| fill | template &lt; class ForwardIterator , class T&gt; void fill \( ForwardIterator first , ForwardIterator last , const T& value \);template &lt; class OutputIterator , class Size , class T&gt; void fill\_n \( OutputIterator first , Size n , const T& value \); | 1 |
| generate | template &lt; class ForwardIterator , class Generator &gt; void generate \( ForwardIterator first , ForwardIterator last , Generator gen \);template &lt; class OutputIterator , class Size , class Generator &gt; void generate\_n \( OutputIterator first , Size n , Generator gen \); | 1 |
| remove | template &lt; class ForwardIterator , class T&gt; ForwardIterator remove \( ForwardIterator first , ForwardIterator last , const T& value \);template &lt; class ForwardIterator , class Predicate &gt; ForwardIterator remove\_if \( ForwardIterator first , ForwardIterator last , Predicate pred \);template &lt; class InputIterator , class OutputIterator , class T&gt; OutputIterator remove\_copy \( InputIterator first , InputIterator last , OutputIterator result , const T& value \);template &lt; class InputIterator , class OutputIterator , class Predicate &gt; OutputIterator remove\_copy\_if \( InputIterator first , InputIterator last , OutputIterator result , Predicate pred \); | Удаляет из полуинтервала все элементы, равные value, или удовлетворяющие предикату, в случае предикатной формы.Есть копирующие формы алгоритмов. |
| unique | template &lt; class ForwardIterator &gt; ForwardIterator unique \( ForwardIterator first , ForwardIterator last \);template &lt; class ForwardIterator , class BinaryPredicate &gt; ForwardIterator unique \( ForwardIterator first , ForwardIterator last , BinaryPredicate pred \);template &lt; class InputIterator , class OutputIterator &gt; OutputIterator unique\_copy \( InputIterator first , InputIterator last , OutputIterator result \);template &lt; class InputIterator , class OutputIterator , class BinaryPredicate &gt; OutputIterator unique\_copy \( InputIterator first , InputIterator last , OutputIterator result , BinaryPredicate pred \); | 1 |
| reverse | template &lt; class BidirectionalIterator &gt; void reverse \( BidirectionalIterator first , BidirectionalIterator last \);template &lt; class BidirectionalIterator , class OutputIterator &gt; OutputIterator reverse\_copy \( BidirectionalIterator first , BidirectionalIterator last , OutputIterator result \); | переворачивает полуинтервал.Есть копирующая форма алгоритма. |
| rotate | template &lt; class ForwardIterator &gt; void rotate \( ForwardIterator first , ForwardIterator middle , ForwardIterator last \);template &lt; class ForwardIterator , class OutputIterator &gt; OutputIterator rotate\_copy \( ForwardIterator first , ForwardIterator middle , ForwardIterator last , OutputIterator result \); | 1 |
| random\_shuffle | template &lt; class RandomAccessIterator &gt; void random\_shuffle \( RandomAccessIterator first , RandomAccessIterator last \);template &lt; class RandomAccessIterator , class RandomNumberGenerator &gt; void random\_shuffle \( RandomAccessIterator first , RandomAccessIterator last , RandomNumberGenerator & rand \); | Перемешивает псевдослучайным образом элементы полуинтервала. Третьим параметром алгоритма может быть генератор случайных чисел. |



