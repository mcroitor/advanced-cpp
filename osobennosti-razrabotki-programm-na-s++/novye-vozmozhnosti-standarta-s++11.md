# Новые возможности стандарта С++11

В 2011 году был принят новый стандарт языка С++. Он позволяет программистам сократить написание кода за счет новых возможностей языка.

## Автоматическое определение типа переменной: 

Возможность определять тип данных в другом типе данных приводит к написанию длинных строчек кода, как это показано в примере ниже:

```cpp
template <class Type>
class adapter{
    Type _object;
public:
    typedef Type* pointer_type;
    adapter(Type p): _object(p) {}
    pointer_type pointer() { return &_object; }
    // ...
};
adapter<int> a(5);
adapter<int>::pointer_type p = a.pointer();
```

Цепочка, указанная в последней строчке может быть очень длинной, и её запись затрудняет как написание кода, так и его читаемость. Поэтому, в новом стандарте было предложено компилятору определять автоматически тип переменной \(при указании ключевого слова auto\), по его значению: 

```cpp
auto val = 5;
adapter<int> a(val); 
auto p = a.pointer();
```

В указанном примере компилятор автоматически определит, что у переменной val тип int, у переменной p – тип adapter&lt;int&gt;::pointer\_type.

## Списки инициализации: 

Идея списков инициализации пришла из С, где объекты структуры могут быть проинициализированы перечислением значений. В С++11 таким образом можно теперь инициализировать объекты классов, при помощи шаблонного класса std::initializer\_list. Реализуется этот механизм следующим образом.

```cpp
class Array10{
    int _val[10];
public:
    Array10(std::initializer_list<int> list);
};

Array10 a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
```

## Нулевой указатель: 

Использование в качестве нулевого указателя значения 0 в некоторых случаях приводило к опасному коду. В приведенном ниже примере :``

```cpp
void func(int);
void func(int*);

int main(){
    func(0);
    return 0;
}
```

Компилятор вызовет функцию с целочисленным параметром, хотя может предполагаться использование второй функции. Для решения этой проблемы предлагается использовать ключевое слово nullptr в качестве нулевого указателя. Инициализация указателя нулем будет выглядеть как **void\* ptr = nullptr;**

## Циклы по коллекциям: 

Во многих языках программирования существуют специальные циклы foreach, которые позволяют перебирать элементы коллекции, не используя доступа через индекс \(или итератор\). В новом стандарте С++ предлагается новая форма записи цикла for: for\( type element: collection\){} . Эта запись означает - "для каждого элемента element из коллекции collection повторять ...". Пример использования данного цикла:

```cpp
int a[5] = {1, 2, 3, 4, 5};
for(auto& el: a){
    ++el;
}
for(auto el: a){
    std::cout << el << " ";
}
```

## Лямбда-функции \(лямбда-выражения\): 

Лямбда-выражения позволяют программистам ускорить написание кода. Под лямбда-выражениями понимают специальный способ записи функторов. Например, функтор sum и лямбда-функции в следующем примере эквивалентны по использованию и поведению:

```cpp
// то же, что и [](int x, int y) -> int{ int result = x + y; return result; }
auto lambda = [](int x, int y) { return x + y; }
struct sum{
    int opertator()(int x, int y){ return x+y;}
};
```

Использование лямбда-функций очень разнообразно и заслуживает отдельной темы.



